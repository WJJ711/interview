# 死锁的4个必要条件

1. 互斥条件
2. 请求与保持条件，（请求第二把锁的同时保持第一把锁）
3. 不剥夺条件
4. 循环等待条件

4个条件缺一不可

# 死锁修复策略

1. 避免策略：哲学家就餐的换手方案、转账换序方案
2. 检测和恢复策略：一段时间检测是否有死锁，如果有就剥夺某一个资源，来打开死锁
3. （不推荐）鸵鸟策略：鸵鸟这种动物在遇到危险的时候，通常就会把头埋在地上，这样一来它就看不到危险了。而鸵鸟策略的意思就是说，如果我们发生死锁的概率极其低，那么我们就直接忽略它，直到死锁发生的时候，再人工修复

# 死锁避免策略

- 思路：避免相反的获取锁的顺序
- 转账时避免死锁
- 实际上不在乎获取锁的顺序


通过hash值判断，每次都让hash值小的先获取锁，破坏了循环等待
```java
int fromHash = System.identityHashCode(from);
int toHash = System.identityHashCode(to);
        if (fromHash < toHash) {
            synchronized (from) {
                synchronized (to) {
                    new Helper().transfer();
                }
            }
        }
        else if (fromHash > toHash) {
            synchronized (to) {
                synchronized (from) {
                    new Helper().transfer();
                }
            }
        }else  {
            synchronized (lock) {
                synchronized (to) {
                    synchronized (from) {
                        new Helper().transfer();
                    }
                }
            }
        }
```

## 哲学家就餐问题的解决方案

- 服务员检测（避免策略），提前看一看会不会发生死锁
- 改变一个哲学家拿叉子的顺序（避免策略），破坏循环等待条件
- 餐票（避免策略）只发n-1个餐票 ，破坏互斥条件
- 领导调节（检测与恢复策略），让一个哲学家放下筷子，破坏不剥夺条件

## 死锁检测算法

- 允许发生死锁
- 每次调用锁都记录
- 定期检查”锁的调用链路图“中是否存在环路
- 一旦发送死锁，就用死锁恢复机制进行恢复

## 死锁恢复机制

- 方法一：进程终止
  - 逐个终止线程，直到死锁消除
  - 终止顺序：
    1. 优先级（是前台交互还是后台处理）
    2. 已占用资源、还需要的资源
    3. 已经运行时间
- 方法二：资源抢占
  - 把已经分发出去的锁给收回来
  - 让线程回退几步，这样就不用结束整个线程，成本比较低
  - 缺点：可能同一个线程一直被抢占，那就造成饥饿

# 实际工程中如何避免死锁

## 1. 设置超时时间

- Lock的`tryLock(long timeout,TimeUnit unit)`
- synchronized不具备尝试锁的能力
- 造成超时的可能性多，发生了死锁、线程陷入死循环、线程执行很慢
- 获取锁失败：打日志、发报警邮件、重启等

## 2. 多使用并发类而不是自己设计锁

- `ConcurrentHashMap、ConcurrentLinkedQueue、AtomicBoolean`等
- 实际应用中`java.util.concurrent.atomic`十分有用，简单方便且效率比使用Lock更高
- 多用并发集合少用同步集合，并发集合比同步集合的可扩展性更好
- 并发场景需要用到map，首先想到用ConcurrentHashMap



3. 尽量降低锁的使用粒度：用不同的锁而不是一个锁
4. 如果能使用同步代码块，就不使用同步方法：自己指定锁对象
5. 给自己的线程起个有意义的名字:debug和排查时事半功倍，框架和JDK这遵循这个最佳实践
6. 避免锁的嵌套：容易死锁
7. 分配资源前先看能不能收回来：银行家算法
8. 尽量不要几个功能用同一把锁：专锁专用

# 活锁

- 虽然线程没有阻塞，也始终在运行（所以叫做“活”锁，线程是“活”的），但是程序却得不到进展，因为线程始终重复做同样的事情
- 如果这里死锁，那么就是这里两个人都始终一动不动，直到对方先抬头，他们之间不再说话了，只是等待

原因：重试机制不变，消息队列始终重试，吃饭始终谦让

- 以太网的指数退避算法

- 加入随机因素

# 工程中的活锁实例：消息队列

- 策略：消息如果处理失败，就放在队列开头重试，则可能会发生一直重试的活锁情况
- 由于依赖服务出了问题，处理该消息一直失败
- 没阻塞，但程序无法继续
- 解决：放到队列尾部、限制重试次数

# 饥饿

- 不设置线程优先级
- 注意某个线程持有锁同时又无线循环而不释放锁，或者某个程序自始至终占用某文件的写锁

# 常见面试问题

- 必然死锁的例子，生产中什么场景会发生死锁
  - 一个方法中获取多个锁
- 发生死锁必须要满足哪些条件
  - 4个条件：1、互斥  2、请求与保持条件  3、不剥夺条件  4、循环等待条件
- 如何定位死锁
  - 使用`jstack`或者`ThreadMXBean`
- 有哪些解决死锁问题的策略
  - 3个
  - 避免策略：哲学家就餐的换手方案、转账换序方案
  - 检测与恢复：一段时间检测是否有死锁，如果有就剥夺某一个资源，来打开死锁
  - （不推荐）鸵鸟策略：鸵鸟这种动物在遇到危险的时候，通常就会把头埋在地上，这样一来它就看不到危险了。而鸵鸟策略的意思就是说，如果我们发生死锁的概率极其低，那么我们就直接忽略它，直到死锁发生的时候，再人工修复
- 讲一讲经典的哲学家就餐问题
- 实际工程中如何避免死锁
- 什么是活跃性问题？活锁、饥饿和死锁的区别？

